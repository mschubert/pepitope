---
title: "Quality control"
output:
  rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Quality control}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{css echo=FALSE}
img {
    border: 0px !important;
    margin: 2em 2em 2em 2em !important;
}
code {
    border: 0px !important;
}
table.dataTable.compact,
.dataTables_wrapper .dataTables_paginate,
.dataTables_wrapper .dataTables_info,
.dataTables_wrapper .dataTables_filter,
.dataTables_wrapper .dataTables_length {
    font-size: 0.7em;
}
```

```{r echo=FALSE, results="hide"}
knitr::opts_chunk$set(
    cache = FALSE,
    echo = TRUE,
    collapse = TRUE,
    comment = "#>"
)
suppressPackageStartupMessages(library(pepitope))
```

This guide shows how to perform quality control on a library using the barcoded
constructs from Variant Calling and a sample sheet that contains a second,
sample-level barcode.

The library itself is generated by ordering the barcoded constructs and then
cloning them into the appropriate expression vectors to function as
MHC-presented peptides.

This workflow can be used either on the construct library, the transduced
cells, or cells after co-culture. The goal of this step is to confirm that all
constructs are present in the approriate proportions. We provide functions to
process and analyze the sequencing data.

Preparation
-----------

### Sequencing output

For this workflow, we need with a single FASTQ file that can contain multiple
samples. In this example, we are simulating our reads, but usually this will be
the file produced by sequencing your pooled and barcode-labeled samples.

Here, we simulate an example file instead:

```{r}
# usually: fastq_file = "/path/to/your/file.fq.gz"
fastq_file = sim_fastq()
```

### Creating a sample sheet

Before we can start working with the FASTQ sequencing output, we need to describe
which samples it contains. For this, we create a sample sheet with the following
columns:

* `sample_id` -- a unique identifier of the sample
* `patient` -- the patient or sample group that the sample comes from
* `rep` -- a number indicating the replicate number
* `origin` -- a descriptor of which kind of sample this is
* `barcode` -- the barcode used to label all condition-specific constructs in the sequencing data

For this example, we have already provided a sample sheet with the package:

```{r}
sample_sheet = system.file("my_samples.tsv", package="pepitope")
```

```{r echo=FALSE}
DT::datatable(readr::read_tsv(sample_sheet), class="compact stripe hover")
```

Sample demultiplexing
---------------------

### Feature syntax

This step is using the `fqtk` toolkit to split the multi-sample FASTQ file into
individual sample files, separated by their sample barcode and save to a
temporary directory.

Here, `read_structures` describes how the split the samples. It has the
following possible fields, preceded by the number of nucleotides in the read. A
`+` instead of a number is used to indicated to use all remaining nucleotides:

* `B` -- the sample barcode to split on (required)
* `T` -- the read sequence with the construct barcode and sequence (required)
* `S` -- skip these nucleotides and do not include in output (optional)

### Demultiplexing call

In this example, we are using a 7-nucleotide barcode for the samples and keep
the rest of the read:

```{r}
temp_dir = demux_fq(fastq_file, sample_sheet, read_structures="7B+T")
```

You can perform additional quality control steps on the sample-level FASTQ
files, e.g. using `fastqc` or `multiqc` (not included in this package).

Construct barcode counting
--------------------------

### Working with the full construct barcode library

In order to count the barcodes from our constructs, as well as assess potential
contaminations from other samples, we need to provide a list of all possible
barcodes.

Here, we are using barcodes from
[this publication](https://www.pnas.org/doi/full/10.1073/pnas.1802640115) and
[Github repository](https://github.com/hawkjo/freebarcodes):

```{r}
lib = "https://raw.githubusercontent.com/hawkjo/freebarcodes/master/barcodes/barcodes12-1.txt"
valid_barcodes = readr::read_tsv(lib, col_names=FALSE)$X1
```

### Counting construct barcodes

The next step is to count the construct barcodes in each individual FASTQ file
after demultiplexing. Internally, we use the `guide-counter` tool to identify the
position the construct barcodes occur in the library reads and subsequently
count the number of occurrences. Here we pass the directory containing the
demultiplexed FASTQ files and the barcode library file with all possible
(not only the used) barcodes:

```{r}
dset = count_bc(temp_dir, valid_barcodes, reverse_complement=TRUE)
```

Here, `dset` will be a list with two objects:

* `meta` -- is a data.frame sample and read information in rows
* `counts` -- is a matrix with constructs in rows and samples in columns

### Merging with construct info

In this step, we add the information of which barcode belongs to which sample
and construct. We can use multiple barcode annotation files, but it is required
that every construct barcodes occurs only in one sample and construct:

```{r eval=F}
bcs = "" # load construct info files here
reps = calc_representation(dset$counts, bcs, dset$meta)
```

Quality Control plots
---------------------

### Plotting total barcode counts

The first overview that we want to get is to know how many barcodes are in which
demultiplexed FASTQ, and whether they match the sample we expect them to be
from. We can plot this the following way, for total read counts on the left and
number of barcodes that have 10 or more reads on the right:

```{r eval=F}
plot_reads(reps, dset$meta)
```

We can also plot this interactively with `plotly`:

```{r eval=F}
library(plotly)
plot = plot_distr(reps)
subplot(ggplotly(plot[[1]]), ggplotly(plot[[2]]), nrows=1)
```

### Representation of individual barcodes

The next question we want to ask is whether the individual construct barcodes
are equally distributed within a sample, and where any potential contaminations
come from. For this, we order the barcodes from least abundant (left) to most
abundant (right) and plot a continuous line for how many reads are sequenced of
this barcode on the y axis:

```{r eval=F}
plot_distr(reps)
```

In a perflectly balanced library we would expect a horizonal line that stays
constant. This, however, is impossible to reach due to the sampling process that
obtains reads stochastically. As the above plot is sampled from a near-perfect
library, this distribution is the best you can expect.

We can also plot this interactively with `plotly`, where we can hover over with
the mouse to see which barcode is in which position exactly:

```{r eval=F}
library(plotly)
ggplotly(plot_distr(reps), height=800)
```

<!-- add cor plots here
### Correlation of read counts between samples

static plot

```{r}
```
-->
